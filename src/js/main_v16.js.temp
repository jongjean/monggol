// ì „ì—­ ë³€ìˆ˜ v16
let scene, camera, renderer;

console.log('ğŸ¬ main.js v13.0 - í…ŒìŠ¤íŠ¸');

let threeInitialized = false;

window.addEventListener('DOMContentLoaded', function() {
    setTimeout(() => {
        const loadingScreen = document.getElementById('loading-screen');
        const openingScene = document.getElementById('opening-scene');
        if (loadingScreen) loadingScreen.style.display = 'none';
        if (openingScene) {
            openingScene.classList.remove('hidden');
            openingScene.style.display = 'flex';
        }
    }, 1000);

    const enterBtn = document.getElementById('enter-btn');
    if (enterBtn) {
        enterBtn.addEventListener('click', function() {
            const openingScene = document.getElementById('opening-scene');
            const exhibitionSpace = document.getElementById('exhibition-space');
            if (openingScene) openingScene.style.display = 'none';
            if (exhibitionSpace) {
                exhibitionSpace.classList.remove('hidden');
                exhibitionSpace.style.display = 'block';
                exhibitionSpace.style.position = 'fixed';
                exhibitionSpace.style.top = '0';
                exhibitionSpace.style.left = '0';
                exhibitionSpace.style.width = '100vw';
                exhibitionSpace.style.height = '100vh';
                exhibitionSpace.style.zIndex = '9999';
            }
            setTimeout(initThreeJS, 100);
        }, { once: true });
    }
});

function initThreeJS() {
    if (threeInitialized) return;
    threeInitialized = true;
    console.log('ğŸš€ Three.js v13.0');

    const container = document.getElementById('exhibition-space');
    if (!container) return;

    scene = new THREE.Scene();
    // scene.background = new THREE.Color(0x87CEEB); // ì£¼ì„ ì²˜ë¦¬
    // scene.fog ì œê±° - í•˜ëŠ˜ ë³´ì´ë„ë¡

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.001, 1000);
    camera.position.set(0, 3, 10);
    camera.lookAt(0, 2, 0);

    const canvas = document.createElement('canvas');
    canvas.style.touchAction = 'none';
    canvas.style.userSelect = 'none';
    canvas.style.webkitUserSelect = 'none';
    renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
    window.scene = scene;
    window.camera = camera;
    window.renderer = renderer;

    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 20, 10);
    scene.add(directionalLight);

    // í…ŒìŠ¤íŠ¸: ë¹¨ê°„ í•˜ëŠ˜ êµ¬ì²´
    // í•˜ëŠ˜ êµ¬ì²´ (khuvsgul_sky_only.jpg?v=1766679064)
    const skyGeometry = new THREE.SphereGeometry(450, 60, 40);
    const skyLoader = new THREE.TextureLoader();
    skyLoader.load('images/background/khuvsgul_sky_only.jpg?v=1766679064', (skyTexture) => {
        const skyMaterial = new THREE.MeshBasicMaterial({
            map: skyTexture,
            side: THREE.BackSide
        });
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        scene.add(sky);
        console.log('ğŸŒ… í•˜ëŠ˜ í…ìŠ¤ì²˜ ë¡œë“œ ì™„ë£Œ');
    });

    // ë°”ë‹¥
    const groundLoader = new THREE.TextureLoader();
    groundLoader.load('images/background/khuvsgul_lake.jpg', (groundTexture) => {
        const groundGeometry = new THREE.CircleGeometry(150, 64);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            map: groundTexture,
            roughness: 0.3,
            metalness: 0.1,
            transparent: true,
            opacity: 0.85
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = 0;
        scene.add(ground);
    });

    // ì‘í’ˆ ë°°ì¹˜ (32ê°œ)
    const artworks = [];
    const artworkData = [];
    const radius = 25; // ê°„ê²© ë„“ê²Œ
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    for (let i = 0; i < 32; i++) {
        const angle = (i / 32) * Math.PI * 2;
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;

        const frameGroup = new THREE.Group();
        frameGroup.userData = { artworkIndex: i + 1 };

        const imgNum = String(i + 1).padStart(3, '0');
        const imagePath = `images/artworks/${imgNum}.jpg`;
        artworkData[i] = imagePath;

        const loader = new THREE.TextureLoader();
        loader.load(imagePath, (texture) => {
            const imgGeometry = new THREE.PlaneGeometry(3.0, 2.0);
            const imgMaterial = new THREE.MeshBasicMaterial({ map: texture });
            const imgMesh = new THREE.Mesh(imgGeometry, imgMaterial);
            frameGroup.add(imgMesh);
        });

        frameGroup.position.set(x, 2.5, z);
        frameGroup.lookAt(0, 2.5, 0);
        scene.add(frameGroup);
        artworks.push(frameGroup);
    }

    let isDragging = false;
    let previousMouseX = 0;
    let previousMouseY = 0;
    let cameraAngleH = 0;
    let cameraAngleV = 0.1;
    let cameraRadius = 10;

    function updateCameraPosition() {
        const y = Math.sin(cameraAngleV) * cameraRadius + 2;
        const horizontalRadius = Math.cos(cameraAngleV) * cameraRadius;
        const x = Math.sin(cameraAngleH) * horizontalRadius;
        const z = Math.cos(cameraAngleH) * horizontalRadius;
        camera.position.set(x, y, z);
        camera.lookAt(0, 2, 0);
        
        const minFOV = 15;
        const maxFOV = 75;
        const t = Math.max(0, Math.min(1, (cameraRadius - 0.5) / 29.5));
        camera.fov = minFOV + (maxFOV - minFOV) * t;
        camera.updateProjectionMatrix();
    }

    canvas.addEventListener('mousedown', (e) => {
        isDragging = true;
        previousMouseX = e.clientX;
        previousMouseY = e.clientY;
    });

    canvas.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const deltaX = e.clientX - previousMouseX;
        const deltaY = e.clientY - previousMouseY;
        cameraAngleH += deltaX * 0.002;
        cameraAngleV += deltaY * 0.001;
        cameraAngleV = Math.max(0, Math.min(Math.PI / 4, cameraAngleV));
        updateCameraPosition();
        previousMouseX = e.clientX;
        previousMouseY = e.clientY;
    });

    canvas.addEventListener('mouseup', () => { isDragging = false; });

    // í„°ì¹˜ ì»¨íŠ¸ë¡¤ (ìŠ¤ë§ˆíŠ¸í°)
    let initialPinchDistance = 0;

    canvas.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
            isDragging = true;
            previousMouseX = e.touches[0].clientX;
            previousMouseY = e.touches[0].clientY;
        } else if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
        }
    });

    canvas.addEventListener('touchmove', (e) => {
        if (e.touches.length === 1 && isDragging) {
            e.preventDefault();
            const deltaX = e.touches[0].clientX - previousMouseX;
            const deltaY = e.touches[0].clientY - previousMouseY;
            cameraAngleH += deltaX * 0.002;
            cameraAngleV += deltaY * 0.001;
            cameraAngleV = Math.max(0, Math.min(Math.PI / 4, cameraAngleV));
            updateCameraPosition();
            previousMouseX = e.touches[0].clientX;
            previousMouseY = e.touches[0].clientY;
        } else if (e.touches.length === 2) {
            e.preventDefault();
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const delta = (initialPinchDistance - distance) * 0.05;
            cameraRadius += delta;
            if (cameraRadius < 0.5) cameraRadius = 0.5;
            if (cameraRadius > 30) cameraRadius = 30;
            updateCameraPosition();
            initialPinchDistance = distance;
        }
    }, { passive: false });

    canvas.addEventListener('touchend', () => {
        isDragging = false;
    });
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        cameraRadius += e.deltaY * 0.005;
        if (cameraRadius < 0.5) cameraRadius = 0.5;
        if (cameraRadius > 30) cameraRadius = 30;
        updateCameraPosition();
    }, { passive: false });

    let lastClickTime = 0;
    canvas.addEventListener('click', (event) => {
        const currentTime = Date.now();
        const isDoubleClick = currentTime - lastClickTime < 300;
        lastClickTime = currentTime;
        if (isDragging) return;

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(artworks, true);
        
        if (intersects.length > 0 && isDoubleClick) {
            const clicked = intersects[0].object.parent;
            const artworkIndex = clicked.userData.artworkIndex;
            const imagePath = artworkData[artworkIndex - 1];
            
            const popup = document.createElement('div');
            popup.style.cssText = 'position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.95);z-index:10000;display:flex;align-items:center;justify-content:center;cursor:pointer;';
            const img = document.createElement('img');
            img.src = imagePath;
            img.style.cssText = 'max-width:90vw;max-height:90vh;object-fit:contain;';
            popup.appendChild(img);
            document.body.appendChild(popup);
            popup.onclick = () => document.body.removeChild(popup);
        }
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
    window.scene = scene;
    window.camera = camera;
    window.renderer = renderer;

        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }
    animate();

    console.log('âœ… v13.0 ì™„ë£Œ');
}

console.log('âœ… main.js v13.0');



// ============================================
// animate ë£¨í”„ì— ê°€ì´ë“œ ì—…ë°ì´íŠ¸ í†µí•©
// ============================================

// requestAnimationFrame í›„í¬
(function() {
    const originalRAF = window.requestAnimationFrame;
    window.requestAnimationFrame = function(callback) {
        return originalRAF.call(window, function(time) {
            // ê°€ì´ë“œ ì—…ë°ì´íŠ¸
            if (typeof animateGuide === 'function') {
            }
            // ì›ë˜ ì½œë°± ì‹¤í–‰
            callback(time);
        });
    };
})();

console.log('âœ… animate ë£¨í”„ í†µí•© ì™„ë£Œ');



// ============================================

// ============================================

// ============================================

// HTML ê³ ì • ê°€ì´ë“œ
function createHTMLGuide() {
    if (document.getElementById('fixedGuide')) return;
    document.body.insertAdjacentHTML('beforeend', '<div id="fixedGuide" class="fixed-guide"><img src="images/guide_on_horse.png" alt="AI ê°€ì´ë“œ"></div>');
    console.log('âœ… HTML ê³ ì • ê°€ì´ë“œ ìƒì„±');
}

function checkGuideProximity() {
    const guide = document.getElementById('fixedGuide');
    if (!guide || !camera || !scene) return;
    let near = false;
    scene.children.forEach(c => {
        if (c.userData && c.userData.artworkId && camera.position.distanceTo(c.position) < 5) near = true;
    });
    guide.classList.toggle('near-artwork', near);
}

setTimeout(() => createHTMLGuide(), 2000);
setInterval(() => checkGuideProximity(), 200);


// ì´ˆê¸°í™”




// ==================== 3D ë„ìŠ¨íŠ¸: ì…ì¥ í›„ì—ë§Œ í‘œì‹œ ====================
function show3DDocentAfterEnter() {
  const docentContainer = document.querySelector('.fixed-docent-3d');
  const docentVideo = document.querySelector('.docent-video');
  const greetingPlayer = document.getElementById('greetingPlayer');
  const openingScene = document.getElementById('opening-scene');

  if (!docentContainer || !docentVideo) {
    console.warn('âš ï¸ 3D ë„ìŠ¨íŠ¸ ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
    return;
  }

  // ì´ˆê¸° ìƒíƒœ: ìˆ¨ê¹€
  docentContainer.style.display = 'none';

  // ì˜¤í”„ë‹ ì”¬ì´ ì‚¬ë¼ì§€ë©´ (ì…ì¥í•˜ë©´) í‘œì‹œ
  const observer = new MutationObserver(() => {
    if (openingScene && openingScene.classList.contains('hidden')) {
      setTimeout(() => {
        docentContainer.style.display = 'block';
        console.log('âœ… 3D ê°¤ëŸ¬ë¦¬ ì…ì¥ â†’ ë„ìŠ¨íŠ¸ í‘œì‹œ');
      }, 1000);
      observer.disconnect();
    }
  });

  if (openingScene) {
    observer.observe(openingScene, { attributes: true, attributeFilter: ['class'] });
  }

  // ë„ìŠ¨íŠ¸ í´ë¦­ â†’ ì¸ì‚¬ë§ ì¬ìƒ
  docentVideo.addEventListener('click', () => {
    if (greetingPlayer) {
      greetingPlayer.style.display = 'block';
      console.log('ğŸ¤ 3D ë„ìŠ¨íŠ¸ í´ë¦­ â†’ ì¸ì‚¬ë§ í”Œë ˆì´ì–´ ì—´ë¦¼');
    }
  });

  console.log('âœ… 3D ë„ìŠ¨íŠ¸ ì‹œìŠ¤í…œ ì´ˆê¸°í™” (ì…ì¥ í›„ í‘œì‹œ)');
}

setTimeout(() => {
  show3DDocentAfterEnter();
}, 2000);


// ==================== 3D ê°¤ëŸ¬ë¦¬ ì¢Œìƒë‹¨ UI í‘œì‹œ ====================

// ì…ì¥ ë²„íŠ¼ í´ë¦­ ê°ì§€
document.addEventListener('DOMContentLoaded', () => {
  const enterBtn = document.querySelector('.enter-btn, #enter-btn, button[onclick*="enter"]');
  if (enterBtn) {
    enterBtn.addEventListener('click', () => {
      console.log('ğŸšª ì…ì¥ ë²„íŠ¼ í´ë¦­ ê°ì§€');

console.log('âœ… 3D ì¢Œìƒë‹¨ UI ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ (main_v16.js)');

// ==================== 3D ê°¤ëŸ¬ë¦¬ UI í‘œì‹œ ====================
(function() {
  console.log('ğŸ¬ 3D ê°¤ëŸ¬ë¦¬ UI ì‹œìŠ¤í…œ ì‹œì‘');
  
  function showGalleryUI() {
    const ui = document.getElementById('mongol-gallery-ui');
    const video = document.getElementById('docent-video-main');
    const greetingPlayer = document.getElementById('greetingPlayer');
    
    if (ui) {
      ui.style.display = 'block';
      console.log('âœ… ëª½ê³¨ ê°¤ëŸ¬ë¦¬ UI í‘œì‹œ ì™„ë£Œ');
      
      // ë„ìŠ¨íŠ¸ í´ë¦­ â†’ ì¸ì‚¬ë§
      if (video && greetingPlayer) {
        video.addEventListener('click', function() {
          greetingPlayer.style.display = 'block';
          console.log('ğŸ¤ ì¸ì‚¬ë§ í”Œë ˆì´ì–´ ì—´ë¦¼');
        });
        
        // hover íš¨ê³¼
        video.addEventListener('mouseenter', function() {
          this.style.transform = 'scale(1.05)';
          this.style.boxShadow = '0 12px 35px rgba(212, 175, 55, 0.9)';
        });
        video.addEventListener('mouseleave', function() {
          this.style.transform = 'scale(1)';
          this.style.boxShadow = '0 8px 25px rgba(0, 0, 0, 0.7)';
        });
      }
    }
  }
  
  // ì…ì¥ ë²„íŠ¼ ê°ì§€
  document.addEventListener('DOMContentLoaded', function() {
    const enterBtn = document.querySelector('.enter-btn, #enter-btn, [class*="enter"]');
    if (enterBtn) {
      enterBtn.addEventListener('click', function() {
        console.log('ğŸšª ì…ì¥ ë²„íŠ¼ í´ë¦­ë¨');
        setTimeout(showGalleryUI, 1500);
      });
    }
    
    // ë°±ì—…: 8ì´ˆ í›„ ìë™ í‘œì‹œ
    setTimeout(function() {
      const ui = document.getElementById('mongol-gallery-ui');
      if (ui && ui.style.display === 'none') {
        console.log('â° íƒ€ì„ì•„ì›ƒ â†’ ìë™ í‘œì‹œ');
        showGalleryUI();
      }
    }, 8000);
  });
})();

